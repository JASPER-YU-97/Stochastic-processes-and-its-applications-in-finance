% volatility波动率，implied隐含波动率，无法采用解析的方法，求数值解
% 因为期权价格和波动率之间的关系是单调的，波动率增加，期权价格增加。
% 所以可以在[A,B]区间内采用牛顿二分法求，[A,B]区间是初始区间，A和B处波动率计算出的期权价格刚好包含当前期权的市场价格。
% 取A和B的中点C，判断波动率C时计算出的期权价格是否大于当前期权的市场价格，若是，舍弃[A,B]区间中的[C,B]段，关注[A,C]段
% 若不是，舍弃[A,B]区间中的[A,C]段，关注[C,B]段.这样不断缩小包围圈。
% 直到得到区间的中值对应的期权价格与当前市场期权价之差小于某一个特定值(置信区间)，循环结束。相应的区间中值可以看做隐含波动率的数值。

%%
S = 100; X = 90; r = 0.05; T = 1; C0 = 15;
% sig?
A = 0.00;
B = 5;
C = (A+B)/2;

error = abs(blsprice(S,X,r,T,C)-C0);% 误差函数(loss function),基于中值C用BS模型计算的期权价格和实际C0期权市场价格的绝对差。

while error>1e-6
    if blsprice(S,X,r,T,C)>C0
        B = C;% 把C的数值付给B，在MATLAB中，赋值是将=之后的值付给=之前的变量，比如S = 100；
        % 这一步实际上就是舍弃舍弃[A,B]区间中的[C,B]段，关注[A,C]段
        C = (A+B)/2;
    elseif blsprice(S,X,r,T,C)<C0 %和Python不同，elseif后面的条件不能省略。
        A = C;% 把C的数值付给A，实际上就是舍弃舍弃[A,B]区间中的[A,C]段，关注[C,B]段
        C = (A+B)/2;
    end
    error = abs(blsprice(S,X,r,T,C)-C0);
end
% 外面用while语句来设定循环终止条件，error值小于等于设定好的误差值1e-6，不然继续循环，填入误差函数的C是循环后更新的C。
C;
%% 验证
blsimpv(S,X,r,T,C0)
% 结果一致，说明用二分法算出的结果是准确的。

