function [c1,p1] = BinoEur1(S0,X,r,T,sig,N)
dt = T/N;
u = exp(sig * sqrt(dt));
d = 1/u;
q = (exp(r * dt) - d)/(u - d);

S = zeros(N+1,1);
% 将矩阵改成向量，并且只保留一个S：价格向量，最后的第N期S价格：u^N*SO, u^(N-1)*d*SO

%% 基于标的资产价格矩阵推出欧式看涨期权
% 最后的第N期的看涨期权价值
for i = 1:N+1
    S(i)=max(u^(N-i+1).*d.^(i-1).*S0 - X, 0);
end

% 从最后一期往前推，因为没有矩阵，所以基于向量计算二叉树，二叉树的节点是后一期二叉树两个分支的期望值。
% 用推出来的前一个节点的值来覆盖对应的位置，然后不断迭代，向前推，需要两层循环，一层是对于覆盖，一层是从N到0的向前迭代(二重循环)。
% 对于第N期，总共有N+1个值(向量)，从N到N+1的覆盖要运算N次；N-1期，就是有N个值，运算N-1次；
% 一直到第1期，运算一次就正好能够得到S0。
% 各期之间，N->1；内层循环(覆盖)，运行次数N->.同时内层运行次数取决于外层推进到的期数。

for j=N:-1:1 %从后往前推，从N到1，间隔为-1.外层循环的次数不断变少，直到第0期
    for i=1:j %内层循环是每次外层循环推进一次，内层从1到N就要完整从1到j的覆盖一次，j之外的向量部分不需要考虑。
        S(i)=exp(-r*dt).*(q.*S(i)+(1-q).*S(i+1));
    end
end
% 得到期权二叉树矩阵，(1,1)是期权t时点期望的贴现值，也就是期权的价格。
%% 取出第一行的数作为期权价格
c1 = S(1);
%% 欧式看跌

% 最后的第N期的看跌期权价值
for i = 1:N+1
    S(i)=max(X - u^(N-i+1).*d.^(i-1).*S0, 0);
end

% 从最后一期往前推
for j=N:-1:1 %从后往前推，从N到1，间隔为-1.外层循环的次数不断变少，直到第0期
    for i=1:j %内层循环是每次外层循环推进一次，内层从1到N就要完整从1到j的覆盖一次，j之外的向量部分不需要考虑。
        S(i)=exp(-r*dt).*(q.*S(i)+(1-q).*S(i+1));
    end
end
%% 取出第一行的数作为期权价格
p1 = S(1);
end